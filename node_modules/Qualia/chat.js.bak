// Generated by CoffeeScript 1.9.2
(function() {
  var db, fs, sqlite3, users;

  fs = require('fs');

  sqlite3 = require('sqlite3').verbose();

  db = new sqlite3.Database(':memory:');

  db.serialize(function() {
    return db.each('SELECT * FROM timeline', function(err, row) {
      var now;
      if (err) {
        now = new Date().toString().encode();
        return db.run('CREATE TABLE timeline (type TEXT, id INTEGER, name TEXT, color TEXT, text TEXT, date TEXT, reply_to INTEGER)', function() {
          return db.run("INSERT INTO timeline (type, id, name, color, text, date) VALUES ('c2VuZA==', 0, 'Y3JlYXRvcg==', 'IzNDRg==', 'SGVsbG8sIFdvcmxkIQ==', '" + now + "')");
        });
      } else {
        return db.each('SELECT COUNT(*) FROM timeline', function(err, row) {
          var count;
          count = row['COUNT(*)'];
          return console.log("DB: timeline " + count + " status.");
        });
      }
    });
  });

  users = [];

  String.prototype.encode = function() {
    return new Buffer(this.toString()).toString('base64');
  };

  String.prototype.decode = function() {
    return (new Buffer(this.toString(), 'base64')).toString();
  };

  var last_disconnect_date = new Date();

  module.exports = function(io) {
    io.sockets.on('connection', function(socket) {
      var copy_return, name, send;
      name = '';
      send = function(row, broadcast) {
        var data, sql, to;
        if (row['reply_to'] != null) {
          to = row['reply_to'];
          sql = "SELECT * FROM timeline WHERE id = " + to;
          console.log(sql + '\n');
          return db.each(sql, function(err, row2) {
            var data;
            data = {
              type: row['type'].decode(),
              id: row['id'],
              name: row['name'].decode(),
              text: row['text'].decode(),
              color: row['color'].decode(),
              date: row['date'].decode(),
              to: {
                type: row2['type'].decode(),
                id: row2['id'],
                name: row2['name'].decode(),
                text: row2['text'].decode(),
                color: row2['color'].decode(),
                date: row2['date'].decode()
              }
            };
            socket.emit('message', data);
            if (broadcast) {
              return socket.broadcast.emit('message', data);
            }
          });
        } else {
          data = {
            type: row['type'].decode(),
            id: row['id'],
            name: row['name'].decode(),
            text: row['text'].decode(),
            color: row['color'].decode(),
            date: row['date'].decode()
          };
          socket.emit('message', data);
          if (broadcast) {
            return socket.broadcast.emit('message', data);
          }
        }
      };
      db.each('SELECT MAX(id) FROM timeline', function(err, row) {
        var max_id, min_id, sql;
        max_id = Number(row['MAX(id)']);
        sql = '';
        if (100 < max_id) {
          min_id = max_id - 100;
          sql = "SELECT * FROM timeline WHERE " + min + " < id AND id < " + max_id;
        } else {
          sql = 'SELECT * FROM timeline';
        }
        console.log(sql + '\n');
        return db.each(sql, function(err, row) {
          return send(row, false);
        });
      });
      copy_return = function(data) {
        return db.each('SELECT MAX(id) FROM timeline', function(err, row) {
          var sql;
          data.id = Number(row['MAX(id)']) + 1;
          data.date = new Date().toString();
          sql = '';
          data.text = data.text.replace(/<script>/g, '&lt;script&gt;').replace(/<\/script>/g, '&lt;/script&gt;');
          if (data.type === 'reply') {
            sql = 'INSERT INTO timeline (type, id, name, color, text, date, reply_to) VALUES ' + ("('" + (data.type.encode()) + "' ," + data.id + ", '" + (data.name.encode()) + "',") + (" '" + (data.color.encode()) + "', '" + (data.text.encode()) + "', '" + (data.date.encode()) + "', " + data.data.to + ")");
          } else {
            sql = 'INSERT INTO timeline (type, id, name, color, text, date) VALUES ' + ("('" + (data.type.encode()) + "' ," + data.id + ", '" + (data.name.encode()) + "',") + (" '" + (data.color.encode()) + "', '" + (data.text.encode()) + "', '" + (data.date.encode()) + "')");
          }
          console.log(sql + '\n');
          return db.run(sql, function(err, row) {
            var ref;
            data.text = data.text.replace(/&lt;script&gt;/g, '<script>').replace(/&lt;\/script&gt;/g, '</script>');
            return send({
              type: data.type.encode(),
              id: data.id,
              name: data.name.encode(),
              color: data.color.encode(),
              text: data.text.encode(),
              date: data.date.encode(),
              'reply_to': (ref = data.data) != null ? ref.to : void 0
            }, true);
          });
        });
      };
      socket.on('connected', function(data) {
        var j, len, user;
        
        name = data.name;
        for (j = 0, leng = users.length; j < len;j++) {
        	if (users[j] == name) {
        		console.log('RE-CONNECT:' + users[j]);
        	}
        }
        for (j = 0, len = users.length; j < len; j++) {
          user = users[j];
          socket.emit('message', {
            type: 'login',
            name: user
          });
        }
        socket.broadcast.emit('message', {
          type: 'login',
          name: name
        });

        users.push(name);
        return console.log(users);
      });
      socket.on('disconnect', function(data) {
        var i, j, ref, results;
        last_disconnect_date = new Date();
        socket.broadcast.emit('message', {
          type: 'logout',
          name: name
        });
        results = [];
        for (i = j = 0, ref = users.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (users[i] === name) {
            users.splice(i, 1);
            console.log(users);
            break;
          } else {
            results.push(void 0);
          }
        }
        return results;
      });
      socket.on('message', function(data) {
        var id, j, len, user;
        switch (data.type) {
          case 'send':
            copy_return(data);
            break;
          case 'reply':
            copy_return(data);
            break;
          case 'file':
            copy_return(data);
            break;
          case 'force-logout':
            console.log('FORCE LOGOUT: ' + data.name);
            for (j = 0, len = users.length; j < len; j++) {
              user = users[j];
              console.log(user.name + ' is ' + data.name);
              if (user.name === data.name) {
                user.socket.emit('message', {
                  type: 'force-logout-request',
                  src_name: data.src_name
                });
              }
            }
            break;
          case 'delete':
            id = data.data.id;
            console.log("DELETE FROM timeline WHERE id = " + id);
            return db.run("DELETE FROM timeline WHERE id = " + id, function(err, row) {
              console.log(err);
              data = {
                type: 'delete',
                id: id
              };
              socket.emit('message', data);
              return socket.broadcast.emit('message', data);
            });
        }
      });
      return socket.on('upload', function(data) {
        var writeStream;
        console.log('upload: ./htdocs/chat/file/' + data.name);
        writeStream = fs.createWriteStream('./htdocs/chat/file/' + data.name);
        writeStream.on('drain', function() {}).on('error', function() {}).on('close', function() {}).on('pipe', function() {});
        writeStream.write(data.file, 'binary');
        return writeStream.end();
      });
    });
    return io;
  };

}).call(this);

//# sourceMappingURL=chat.js.map
