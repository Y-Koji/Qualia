
fs = require 'fs'
sqlite3 = require('sqlite3').verbose()
db = new sqlite3.Database('qualia.db')

db.serialize ->
	db.each 'SELECT * FROM timeline', (err, row) ->
		if err
			now = new Date().toString().encode()
			db.run 'CREATE TABLE timeline (type TEXT, id INTEGER, name TEXT, color TEXT, text TEXT, date TEXT, reply_to INTEGER)', ->
				db.run "INSERT INTO timeline (type, id, name, color, text, date) VALUES ('c2VuZA==', 0, 'Y3JlYXRvcg==', 'IzNDRg==', 'SGVsbG8sIFdvcmxkIQ==', '#{now}')"
		else
			db.each 'SELECT COUNT(*) FROM timeline', (err, row) ->
				count = row['COUNT(*)']
				# console.log "DB: timeline #{count} status."

users = []

String.prototype.encode = ->
	return new Buffer(@.toString()).toString('base64')
String.prototype.decode = ->
	return (new Buffer(@.toString() , 'base64')).toString()

module.exports = (io) ->
	io.sockets.on 'connection', (socket) ->
		name = ''

		send = (row, broadcast) ->
			if row['reply_to']?
				to = row['reply_to']
				sql = "SELECT * FROM timeline WHERE id = #{to}"
				console.log sql + '\n'
				# リプライ先の投稿を取得
				db.each sql, (err, row2) ->
					data =
						type: row['type'].decode()
						id: row['id']
						name: row['name'].decode()
						text: row['text'].decode()
						color: row['color'].decode()
						date: row['date'].decode()
						to:
							type: row2['type'].decode()
							id: row2['id']
							name: row2['name'].decode()
							text: row2['text'].decode()
							color: row2['color'].decode()
							date: row2['date'].decode()
					socket.emit 'message', data
					if broadcast
						socket.broadcast.emit 'message', data
			else
				data =
					type: row['type'].decode()
					id: row['id']
					name: row['name'].decode()
					text: row['text'].decode()
					color: row['color'].decode()
					date: row['date'].decode()
				socket.emit 'message', data
				if broadcast
					socket.broadcast.emit 'message', data

		# ログイン時に過去の投稿を読み込む
		db.each 'SELECT MAX(id) FROM timeline', (err, row) ->
			max_id = Number(row['MAX(id)'])
			sql = ''
			if 100 < max_id
				min_id = max_id - 100
				sql = "SELECT * FROM timeline WHERE #{min_id} < id AND id < #{max_id}"
			else
				sql = 'SELECT * FROM timeline'

			console.log sql + '\n'
			db.each sql, (err, row) ->
				send row, false

		copy_return = (data) ->
			db.each 'SELECT MAX(id) FROM timeline', (err, row) ->
				data.id = Number(row['MAX(id)']) + 1
				data.date = new Date().toString()
				sql = ''
				data.text = data.text.replace(/<script>/g, '&lt;script&gt;').replace(/<\/script>/g, '&lt;/script&gt;')
				if data.type is 'reply'
					sql = 'INSERT INTO timeline (type, id, name, color, text, date, reply_to) VALUES ' +
						"('#{data.type.encode()}' ,#{data.id}, '#{data.name.encode()}'," +
						" '#{data.color.encode()}', '#{data.text.encode()}', '#{data.date.encode()}', #{data.data.to})"
				else
					sql = 'INSERT INTO timeline (type, id, name, color, text, date) VALUES ' +
						"('#{data.type.encode()}' ,#{data.id}, '#{data.name.encode()}'," +
						" '#{data.color.encode()}', '#{data.text.encode()}', '#{data.date.encode()}')"
				console.log sql + '\n'
				db.run sql, (err, row) ->
					data.text = data.text.replace(/&lt;script&gt;/g, '<script>').replace(/&lt;\/script&gt;/g, '</script>')
					send(
						type: data.type.encode()
						id: data.id
						name: data.name.encode()
						color: data.color.encode()
						text: data.text.encode()
						date: data.date.encode()
						'reply_to': data.data?.to
					, true)

		socket.on 'connected', (data) ->
			name = data.name
			for user in users
				socket.emit 'message',
					type: 'login'
					name: user.name
			socket.broadcast.emit 'message',
				type: 'login'
				name: name
			users.push
				name: name
				socket: socket
			console.log users
		socket.on 'disconnect', (data) ->
			socket.broadcast.emit 'message',
				type: 'logout'
				name: name
			for i in [0..(users.length - 1)]
				if users[i].name is name
					users.splice i, 1
					console.log users
					break
		socket.on 'message', (data) ->
			switch data.type
				when 'send'
					copy_return data
					break
				when 'reply'
					copy_return data
					break
				when 'file'
					copy_return data
					break
				when 'force-logout'
					console.log 'FORCE LOGOUT: ' + data.name
					for user in users
						console.log user.name + ' is ' + data.name
						if user.name is data.name
							user.socket.emit 'message',
								type: 'force-logout-request'
								src_name: data.src_name
					break
				when 'delete'
					id = data.data.id
					console.log "DELETE FROM timeline WHERE id = #{id}"
					db.run "DELETE FROM timeline WHERE id = #{id}", (err, row) ->
						console.log err
						data =
							type: 'delete'
							id: id
						socket.emit 'message', data
						socket.broadcast.emit 'message', data
		socket.on 'upload', (data) ->
			console.log 'upload: ./htdocs/chat/file/' + data.name
			writeStream = fs.createWriteStream('./htdocs/chat/file/' + data.name)
			writeStream
				.on 'drain', -> return 
				.on 'error', -> return 
				.on 'close', -> return
				.on 'pipe', -> return
			writeStream.write data.file, 'binary'
			writeStream.end()
			
	return io